# 面向对象

面向对象是一种编程范式。

范式： 可以认为是一组方法论；

编程范式： 一组如何组织代码的方法论；


## 主流的编程范式：

    PP：面向过程； C语言为代表；
    IP：面向指令； 汇编为代表；更接近于机器；
    FP：函数式编程；要求：无副作用(相同的输入，总是能得到相同的输出)
    LP：面向逻辑的编程； 抽象成与、或、非三个逻辑状态；prolog为代表，在人工智能上用得比较多；
    OOP：面向对象的编程；
    AOP：面向方面的编程；在python中的体现为装饰器；SQL；


面向对象(OOP)： Object Oriented Programming；

## OOP的世界观：

* 世界是有对象组成的；
* 对象具有运动规律和内部状态；
* 对象之间可以相互作用；


以目前人类的认知来说，OOP是最接近真实世界的编程范式；

## 面向对象的特性：

* 唯一性：对象都是唯一的，不存在两个相同的对象，除非他们是同一个对象；
* 分类性：对象是可分类的；

程序是对世界的模拟；


## OOP的特征：

* 封装
* 继承 
* 多态


## Python的面向对象：

```python 
from collections import namedtuple

pet = namedtuple('Pet',['name','age'])

# 使用命名元组的目的： 为了组织数据；

lily = ('lily',3)

# 命名元组有什么优势：组织得更好，字段有名字；

Door = namedtuple('Door',['number','status'])

door = Door(1001,'closed')

print(door.number)

print(door.status)
# 能访问其属性，但是不能对其执行修改操作；因为元组是不可变对象；
```

```python 
class Door:
    def __init__(self,number,status):
        self.number = number
        self.status = status

door = Door(1001,'closed')
print(door.status)
print(door.number)

door.status = 'opening'
print(door.status)
```

## 定义一个类：

```python
class 类名:
    块
```

点号(.)用于访问对象的属性；

```python 
In [1]: class A:
   ...:     pass 
   ...: 

In [2]: a = A()   # 实例化对象；

In [3]: a
Out[3]: <__main__.A at 0x7fd65ef36630>
```

* 创建对象使用`类名(__init__函数中除第一个参数外的参数列表)`
* 创建对象的时候，实际执行了__init__函数；


```python 
In [13]: class D:
    ...:     def __init__(self):   # self引用的是实例变量，即实例化时的实例名称；
    ...:         print(id(self))
    ...:     
    ...:         

In [14]: d = D()
140558753338424

In [15]: id(d)
Out[15]: 140558753338424
```

* `__init__`函数不会创建对象；
* `__init__`函数初始化对象；
  - 首先创建对象；
  - 对象作为self参数传递给__init__函数；
  - 返回self 

```python 
In [17]: class Door:
    ...:     def __init__(self,number,status):  # 此处的self只是习惯用法，可以是其他符合规定的标识符；
    ...:         self.number = number
    ...:         self.status = status
    ...:     def open(self):   # 定义在类中的函数，被称为方法；
    ...:         self.status = 'opening'
    ...:         

In [18]: door = Door(1001,'closed')

In [19]: door.status
Out[19]: 'closed'

In [20]: Door.open(door)

In [21]: door.status
Out[21]: 'opening'

In [22]: door.status = 'closed'

In [23]: door.open()  # 当使用对象来调用的时候，第一个参数会自动的传入；

In [24]: door.status
Out[24]: 'opening'
```

方法定义在类中的好处：
* 保持一个纯净的命名空间；
* 直接使用对象来调用方法时，第一个参数(self)会自动的传入；


小结：
* 如何定义类；
* 如何创建对象；
* 如何定义方法；
* 方法调用； 


## 作用域：


```python 
In [26]: class E:   
    ...:     NAME = 'E'     # 类的直接下级作用域，叫做类变量；
    ...:     def __init__(self,name):
    ...:         self.name = name  # 关联到实例的变量，叫做实例变量；
    ...:         

In [27]: e = E('e')

In [28]: E.NAME
Out[28]: 'E'

In [29]: e.NAME
Out[29]: 'E'
# 类变量对类和实例都可见；


In [31]: e2 = E('e2')

In [32]: e2.NAME
Out[32]: 'E'

In [33]: e2.name
Out[33]: 'e2'

# 所有实例共享类变量；

In [34]: e2.NAME = 'E2'

In [35]: e2.NAME
Out[35]: 'E2'

In [36]: e.NAME
Out[36]: 'E'

# python可以动态的给实例和类增减属性：

In [37]: e.xxx = 3  

# 当给实例的类变量赋值时，相当于动态的给这个实例增加了一个属性，覆盖了类变量；

In [38]: e.xxx
Out[38]: 3

In [39]: e2.xxx
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-39-8ca2718f6555> in <module>()
----> 1 e2.xxx

AttributeError: 'E' object has no attribute 'xxx'

```

* Example：

```python
class Door:
    name = "Main door"   # 类变量，所有实例共享类变量；
    def __init__(self,number=None,status=None):
        if number == None:
            self.number = 1001   # 关联到实例的变量，叫做实例变量；
        else:
            self.number = number

        if status == None:
            if status == None:
                self.status = 'closed'
            else:
                self.status = status

door = Door(1001)
door2 = Door(1002)

# 类变量对类和实例都可见；
print(Door.name)   # Main door
print(door.name)   # Main door
print(door2.name)  # Main door

# python可以动态地给实例和类增减属性：
Door.person = 'kalaguiyin'
door.person = 'sslinux'

print(Door.person) # kalaguiyin
print(door.person) # sslinux

print(door2.person) # kalaguiyin   因为上面并没有直接给实例door2增加属性person,所以输出的是类变量：Door.person

# 当给实例的类变量赋值时，相当于动态的给这个实例增加了一个属性，覆盖了类变量；
print(Door.name)   # Main door
print(door.name)   # Main door
print(door2.name)  # Main door

door.name = "Second Door"

print(Door.name)   # Main door
print(door.name)   # Second Door
print(door2.name)  # Main door

door.xxx = 3
# print(Door.xxx)    # type object "Door" has no attribute 'xxx'
print(door.xxx)      # 3
# print(door2.xxx)     # 'Door' object has no attribute 'xxx'
```


* **赋值即创建**

```python
def outter():
    v = 3 
    def inner():
        v = 4
        
class E:
    NAME = "E"  # 类的直接下级作用域，叫做类变量；
    
    def __init__(self,name):
        self.name = name  # 关联到实例的变量，叫做实例变量；
```


## 属性的查找顺序：
* `__dict__`
* `__class__`
后续还有更多的查找顺序；

```python
In [38]: class E:
    ...:     NAME = "E"
    ...:     def __init__(self,name):
    ...:         self.name = name 
    ...:         

In [39]: e = E('e')

In [40]: e.NAME    # 相当于： e.__class__.NAME 
Out[40]: 'E'

In [41]: e.__class__.NAME
Out[41]: 'E'

In [42]: e.NAME = 'xxx'    # 相当于： e.__dict__['NAME']

In [43]: e.__dict__['NAME'] = 'X'

In [44]: e.NAME
Out[44]: 'X'

In [46]: e.__class__.NAME
Out[46]: 'E'

```


## 类装饰器

```python 
In [52]: def set_name(cls,name):
    ...:     cls.NAME = name 
    ...:     return cls
    ...: 

In [53]: class F:
    ...:     pass 
    ...: 

In [54]: F1 = set_name(F,'F')

In [55]: f1 = F1()

In [56]: F1.NAME
Out[56]: 'F'

In [57]: f1.NAME
Out[57]: 'F'

#########################################################
In [58]: def set_name(name):
    ...:     def warp(cls):
    ...:         cls.NAME = name 
    ...:         return cls 
    ...:     return warp
    ...: 

In [60]: @set_name('G')
    ...: class G:
    ...:     pass 
    ...: 

In [61]: G.NAME
Out[61]: 'G'


# 相当于：
# class G:
#     pass 
# 
# G = set_name('G')(G)

print(G.NAME)
```


```python
# 装饰器通常用于给类增加属性；

# 此处增加的是一个方法；增加方法有其他更好的实现方式；
def print_name(cls):
    def get_name(self):       # 整个get_name方法相当于写在class中的；
        return cls.__name__
    cls.__get_name__ = get_name
    return cls

@print_name
class H:    # 整个类H，被传递到print_name中作为cls；
    pass

h = H()
print(h.__get_name__())
```


* **方法都是类级的；** 


## 类方法/静态方法

方法的定义都是类级的，但是有的方法使用实例调用，有的方法使用类来调用；


```python 
In [54]: class I:
    ...:     def print(self):
    ...:         print('instance method')
    ...:         

In [55]: i = I()

In [56]: i.print() # 实例调用实例方法时，会自动传入self参数，self为实例本身； I.print(i)
instance method

In [57]: I.print()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-57-acb53bc932b5> in <module>()
----> 1 I.print()

TypeError: print() missing 1 required positional argument: 'self'

In [58]: I.print(i)
instance method

```
**实例方法只能由实例调用；**


## 类方法：

```python 
In [59]: class I:
    ...:     def print(self):
    ...:         print('instance method')
    ...:     @classmethod    # 内置的类装饰器，使用该装饰器后，调用I.class_print()时，传递的第一个参数不再是instance，而是class本身；
    ...:     def class_print(cls): # 这样的方法是类方法；
    ...:         print('class method')
    ...:         

In [60]: I.class_print()
class method

In [61]: class I:
    ...:     def print(self):
    ...:         print('instance method')
    ...:     @classmethod
    ...:     def class_print(cls):
    ...:         print(id(cls))
    ...:         print('class method')
    ...:         

In [62]: I.class_print()
30501992
class method

In [63]: i = I()

In [64]: i.class_print()  # 类方法可以被实例使用；并且被实例使用时，传入的第一个参数还是类；
30501992
class method
```

类方法与实例方法的区别：

    传入的第一个参数class的就是类方法；类方法无需实例化即可执行；所有实例共享；
    传入的第一个参数instance的就是实例方法；

```python 
In [65]: class I:
    ...:     def print(self):
    ...:         print('instance method')
    ...:     @classmethod
    ...:     def class_print(cls):
    ...:         print(id(cls))
    ...:         print('class method')
    ...:     @staticmethod  # 当一个方法，被staticmethod装饰的时候，不会自动传递第一个参数，这样的方法叫静态方法；
    ...:     def static_print():
    ...:         print('static method')
    ...:         

In [66]: i = I()

In [67]: i.static_print()
static method
```

```python 
# 方法的定义都是类级的，但是有的方法使用实例调用，有的方法使用类来调用；

class I:
    def instance_print(self):
        print('instance method')

    @classmethod # 内置类装饰器，当一个方法被classmethod装饰的时候，调用该方法时，传递的第一个参数不再是instance，而是class本身；
    def class_print(cls):
        print(id(cls))
        print('class method')

    @staticmethod   # 当一个方法，被staticmethod装饰的时候，不会自动传入第一个参数，这样的方法叫静态方法；
    def static_print():
        print('static method')

    def xxx_print():    # 不加任何装饰器，也不传递self，实例不能调用； 只是一个定义在类作用域下的函数；
        print("this is a function")


i = I()

# 调用实例方法：
i.instance_print()    # 实例调用实例方法的时候，会自动传入self参数，self为实例本身；

# 调用类方法：
I.class_print()   # 37893592   class method
print(id(I))      # 37893592

i.class_print()   # 类方法可以被实例使用，并且被实例使用时，传入的第一个参数还是类；
                  # 类方法无需实例化就可以执行；

# 调用静态方法：
i.static_print()


# 调用类中定义的普通函数：
I.xxx_print()
``` 

---

## 访问控制

```python 
class Door:
    def __init__(self,number,status):  # 此处的self只是习惯用法，可以是其他符合规定的标识符；
        self.number = number
        self.status = status

    def open(self):   # 定义在类中的函数，被称为方法；
        self.status = 'opening'

    def close(self):
        self.status = 'closed'

door = Door(1001,'closed')
print(door.status)
door.status = 'fuck it'   # 我们希望某个属性的取值只能是规定的几个，不能自定义；
print(door.status)
```

```python 
class Door:
    def __init__(self,number,status):  # 此处的self只是习惯用法，可以是其他符合规定的标识符；
        self.number = number
        self.__status = status  # 双下划线开始，非双下划线结尾的都是私有的，在类外部无法访问；

    def open(self):   # 定义在类中的函数，被称为方法；
        self.__status = 'opening'

    def close(self):
        self.__status = 'closed'

    def status(self):
        return self.__status
    
    def __set_number(self,number):   # 双下划线开始，非双下划线结尾的方法也是私有方法；
        self.number = number

door = Door(1001,'closed')
door.__status = 'fuck it'  # 给对象创建了新的属性，并没有修改__status。
print(door.__status)
print(door.status())
```

**所有双下划线开始，非双下划线结尾的成员，都是私有成员**

## python访问私有成员：

    _类名 + 带双下划线的属性

**python的私有成员是通过改名实现的；**

```python 
In [71]: class Door:
    ...:     def __init__(self,number,status):  # 此处的self只是习惯用法，可以是其他符合规定的标识符；
    ...:         self.number = number
    ...:         self.__status = status
    ...: 
    ...:     def open(self):   # 定义在类中的函数，被称为方法；
    ...:         self.__status = 'opening'
    ...: 
    ...:     def close(self):
    ...:         self.__status = 'closed'
    ...: 
    ...:     def status(self):
    ...:         return self.__status
    ...: 
    ...:     def __set_number(self,number):   # 双下划线开始，非双下划线结尾的方法也是私有方法；
    ...:         self.number = number
    ...:         

In [72]: door = Door(1001,'closed')

In [73]: door.__status
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-73-d55234f04e7f> in <module>()
----> 1 door.__status

AttributeError: 'Door' object has no attribute '__status'

In [75]: door._Door__status #  _类名 + 带双下划线的属性,访问私有成员；
                            # 单下划线(_) + 类名. + 带双下划线的属性名，访问私有成员；
Out[75]: 'closed'

In [76]: door._Door__status = 'opening'

In [77]: door.status()
Out[77]: 'opening'

In [78]: door._Door__status = 'fuck it'

In [79]: door.status()
Out[79]: 'fuck it'
```
### 严格的说，Python里没有真正的私有成员；

**除非真的有必要，并且清楚明白地知道会有什么后果，否则不要用这个黑魔法(使用改名后的属性名：_Class.__attribute)。** 

**90%的程序员，有生之年用不到。对封装性是一种破坏。**

猴子补丁：

    gevent；  需要使用上述访问私有成员的方法；

### 以单下划线(_)开头的成员，是一种习惯用法，标记此成员为私有，但是解释器并不做任何处理。只是约定俗成，不强制要求。
```python 
In [80]: class J:
    ...:     def __init__(self):
    ...:         self._a = 3
    ...:         

In [81]: j = J()

In [82]: j._a
Out[82]: 3

In [83]: j._a = 4

In [84]: j._a
Out[84]: 4

In [85]: j.__dict__
Out[85]: {'_a': 4}
```

## property装饰器会把一个仅有self参数的函数，变成一个属性；属性的值为方法的返回值；

```python 
In [73]: class Door:
    ...:     def __init__(self,number,status):
    ...:         self.number = number
    ...:         self.__status = status
    ...: 
    ...:     def open(self):
    ...:         self.__status = 'opening'
    ...: 
    ...:     def close(self):
    ...:         self.__status = 'closed'

    ...:     @property          # property装饰器会把一个仅有self参数的函数，变成一个属性；属性的值为方法的返回值；
    ...:     def status(self):
    ...:         return self.__status
    ...:         

In [74]: door = Door(1001,'closed')

In [75]: door.status
Out[75]: 'closed'

In [76]: door.status()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-76-76c604e52a9b> in <module>()
----> 1 door.status()

TypeError: 'str' object is not callable

```

```python
In [77]: class Door:
    ...:     def __init__(self,number,status):
    ...:         self.__number = number
    ...:         self.__status = status
    ...: 
    ...:     def open(self):
    ...:         self.__status = 'opening'
    ...: 
    ...:     def close(self):
    ...:         self.__status = 'closed'
    ...:     @property
    ...:     def status(self):
    ...:         return self.__status
    ...:     def __set_nubmer(self,number):
    ...:         self.__number = number 
    ...:     def set_number(self,number):
    ...:         if isinstance(number,int) and number > 0 and number < 10000:
    ...:             self.__number = number
    ...:     def number(self):
    ...:         return self.__number
    ...:     
In [79]: door = Door(1001,'closed')

In [81]: door.status
Out[81]: 'closed'

In [82]: door.number()
Out[82]: 1001

In [83]: door.set_number(5001)

In [85]: door.number()
Out[85]: 5001

In [86]: door.set_number('abcd1234')

In [87]: door.number()
Out[87]: 5001

```

```python 
In [88]: class Door:
    ...:     def __init__(self,number,status):
    ...:         self.__number = number
    ...:         self.__status = status
    ...: 
    ...:     def open(self):
    ...:         self.__status = 'opening'
    ...: 
    ...:     def close(self):
    ...:         self.__status = 'closed'
    ...:     @property    
    ...:     def status(self):
    ...:         return self.__status
    ...:     def __set_nubmer(self,number):
    ...:         self.__number = number 

    ...:     @property    # property装饰器会把一个仅有self参数的函数，变成一个属性；属性的值为方法的返回值；
    ...:     def number(self):
    ...:         return self.__number
    ...:     
            # property setter 这个装饰器，可以把一个方法转化为对此属性赋值，但此方法有一定要求：
            # 1、必须和被property装饰的属性同名；
            # 2、必须接受两个参数：self和value，value为所赋的值
            # 3、前后顺序：property setter所装饰的方法在被property装饰的属性之后；
    ...:     @number.setter    
    ...:     def number(self,number):
    ...:         if isinstance(number,int) and number > 0 and number < 10000:
    ...:             self.__number = number
    ...:         

In [89]: door = Door(1001,'closed')

In [90]: door.number
Out[90]: 1001

In [91]: door.number = 5001

In [92]: door.number
Out[92]: 5001

In [93]: door.number = 'abcd1234'   # 对使用property setter装饰器的属性赋值(赋不符合要求的值，不生效)

In [94]: door.number
Out[94]: 5001

```

```python 
In [96]: class Door:
    ...:     def __init__(self,number,status):
    ...:         self.__number = number
    ...:         self.__status = status
    ...:         self.xxx = 5
    ...: 
    ...:     def open(self):
    ...:         self.__status = 'opening'
    ...: 
    ...:     def close(self):
    ...:         self.__status = 'closed'
    ...:     @property
    ...:     def status(self):
    ...:         return self.__status
    ...:     def __set_nubmer(self,number):
    ...:         self.__number = number 
    ...:     @property
    ...:     def number(self):
    ...:         return self.__number
    ...:     
    ...:     @number.setter    
    ...:     def number(self,number):
    ...:         if isinstance(number,int) and number > 0 and number < 10000:
    ...:             self.__number = number

    ...:     @number.deleter   # 动态删除经过property装饰过的方法时，执行该方法；
    ...:     def number(self):
    ...:         print("can't remove number property")
    ...:             

In [97]: door = Door(1001,'close')

In [98]: door.xxx   # 临时添加的无关紧要的属性；
Out[98]: 5

In [99]: del door.xxx   # 动态删除属性；

In [100]: door.xxx
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-100-045038705f09> in <module>()
----> 1 door.xxx

AttributeError: 'Door' object has no attribute 'xxx'

In [101]: del door.open    # 无法删除方法；
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-101-10518c49374f> in <module>()
----> 1 del door.open

AttributeError: open

In [102]: del door.number       # 动态删除经过property装饰的方法时，执行使用property deleter装饰的方法；
can't remove number property

上述的三个经过property装饰的方法还可以使用以下的方式定义：
number = property(lambda self: self.__number,lambda self,value:self.__number = value,lambda self: print("can't remove number property"))
```

## 以上内容为——封装；
私有属性也是封装的一种；
property使得封装更为容易；



## 类的继承：

```python 
# 继承的基本写法：
class Base:
    def base_print(self):
        print('base')

class A(Base):  # 在类名后加括号，括号中是继承(类的)列表； 括号中的称为父类，或者基类，或者超类；
    def a_print(self):
        print('a')

a = A()

a.a_print()     # 子类的方法； 
a.base_print()  # 继承自Base类的方法；
```

**继承的一个明显的好处就是可以获取父类的属性和方法。代码复用**

```python 
class Base:
    PUBLIC_CLASS_VAR = 'PUBLIC_CLASS_VAR'     
    _PRIVATE_CLASS_VAR = 'PRIVATE_CLASS_VAR' 

    def __init__(self):
        self.public_instance_var = 'public_instance_var'
        self.__private_instance_var = 'private_instance_var'

    @classmethod
    def public_class_method(cls):
        return 'public_class_method'

    @classmethod
    def __private_class_method(cls):
        return 'private_class_method'

    @staticmethod
    def public_static_method():
        return 'public static method'

    @staticmethod
    def __private_static_method():
        return 'private static method'

    def public_instance_method(self):
        return 'public_instance_method'

    def __private_instance_method(self):
        return 'private_instance_method'

class Sub(Base):
    def print(self):
        print(self.public_static_method())

sub.__dict__
```

验证：
* 凡是公有的(属性和方法)都能继承；
* 凡是私有的(属性和方法)都不能继承；因为私有的名称转换了。
* 原来是什么，继承过来还是什么：原来是类的属性和方法，继承过来还是类的，原来是实例的，继承过来还是实例的；



---


## 方法重写：

```python 
In [90]: class Base:
    ...:     def print(self):
    ...:         print('Base.print')
    ...:         

In [91]: class Sub(Base):
    ...:     def print(self):  ## 当子类和父类有同名成员的时候，子类的成员会覆盖父类的同名成员；
                               ## 但是结果是无法调用父类的方法；
    ...:         print('Sub.print')
    ...:         

In [92]: sub = Sub()

In [93]: sub.print()
Sub.print
```

```python 
class Base:
    def print(self):
        print('Base.print')

class Sub(Base):
    def foo(self):
        self.print()  # 调用父类的print方法；

sub = Sub()

sub.foo()
```

```python
class Base:
    def print(self):
        print('Base.print')

class Sub(Base):
    def print(self):        # 已经将父类的print方法重写了；
        print('Sub print')

    def foo(self):
        self.print()  # 此时调用的是子类的方法；

sub = Sub()

sub.foo()
```


```python 
class Base:
    def print(self):
        print('Base.print')
        

class Sub(Base):
    def print(self):
        print('Sub print')

    def foo(self):
        # self.print()  # 此时调用的是子类的方法；
        super().print() # 调用的是父类的print方法；
        super(Sub,self).print() # 和前一行是一样的；

        # super(Sub).print()
        # super(Base,Sub).print()

sub = Sub()

sub.foo()
```

```python 
class Base:
    def print(self):
        print('Base.print')

    @classmethod
    def cls_print(cls):
        print("Base.cls_print")


class Sub(Base):
    def print(self):
        print('Sub print')

    @classmethod
    def cls_print(cls):
        print("Sub.cls_print")

    def foo(self):
        # self.print()  # 此时调用的是子类的方法；
        super().print() # 调用的是父类的print方法；
        super(Sub,self).print() # 和前一行是一样的；
        # super(Sub).print()
        # super(Base,Sub).print()

    @classmethod
    def cls_foo(cls):
        cls.cls_print()
        Base.cls_print()
        super().cls_print()

sub = Sub()

sub.cls_foo()
```

```python
class SubSub(Sub):
    def print(self):
        print('SubSub.print')

    def foo(self):
        # 调用Base的print
        super(Sub,self).print()

SubSub().foo()
```

```python 
class SubSub(Sub):
    def print(self):
        print('SubSub.print')

    @classmethod
    def cls_print(cls):
        print('SubSub.cls_print')

    def foo(self):
        # 调用Base的print
        super(Sub,self).print()  # 代理TYPE的父类的方法，并且使用obj绑定；
                                # 第一个参数 指定调用谁的直接父类；
                                # 第二个参数 指定当调用时，传递什么作为方法的第一个参数； 

    @classmethod
    def cls_foo(cls):
        # 调用Base的cls_print方法；
        # Base.cls_print()
        super(Sub,cls).cls_print()

SubSub().cls_foo()
```


```python 
class Base:
    def print(self):
        print("Base.print")

    @classmethod
    def cls_print(cls):
        print('Base.cls_print')


class Sub(Base):
    def print(self):
        print('Sub.print')

    @classmethod
    def cls_print(cls):
        print("Sub.cls_print")

    def foo(self):
        # self.print()   # 调用父类的print方法；
        super().print()
        # super(Base,Sub).print()

    @classmethod
    def cls_foo(cls):
        # cls.cls_print()
        # Base.cls_print()
        super().cls_print()
        # super(Base,cls).cls_print()    # wrong;

class SubSub(Sub):
    def print(self):
        print('SubSub.print')

    @classmethod
    def cls_print(cls):
        print("SubSub.cls_print")


    def foo(self):
        # 调用Base的print；
        super(Sub,self).print()  # 代理TYPE的父类的方法，并且使用obj绑定；
        pass

    @classmethod
    def cls_foo(cls):
        Base.cls_print()
        super(Sub,cls).cls_print()


SubSub().foo()
print("*"*30)
SubSub().cls_foo()

```


**super并不妨碍私有属性的保护。** 


[Python开发社区](http://www.ctolib.com)

---

### 当父类含有一个带参数的初始化方法的时候，子类一定需要一个初始化方法，并在初始化方法中调用父类的初始化方法；


```python 
class Base:
    def __init__(self,a,b):
        self.__a = a
        self.__b = b

    def sum(self):
        return self.__a + self.__b

class Sub(Base):
    def __init__(self,a,b,c):
        self.c = c
        # self.a = a
        # self.b = b
        super().__init__(a,b)

sub = Sub(1,2,3)
print(sub.sum())
```
---


```python 
class Base:
    def __init__(self):
        self.a = 3

class Sub(Base):
    def __init__(self):
        self.a = 5

    def print(self):
        print(self.a)
        print(super().a)   # 获取父类的实例变量：  这是一个伪命题；不存在这样的问题；


Sub().print()
```


```python
class Base:
    NAME = "BASE"

class Sub(Base):
    NAME = 'SUB'

    def print(self):
        print(self.NAME)
        print(super().NAME)
        print(super(Sub,Sub).NAME)    # 获取父类的类变量；
        print(Base.NAME)

Sub().print()
```

## **super对象只能获取类的属性**


## 多继承：

如果不显式说明，则类继承自object类；

```python 
In [6]: class A(object):
   ...:     pass 
   ...: 

In [7]: class A():
   ...:     pass
   ...: 

In [8]: class A:
   ...:     pass
   ...: 
```

```python
In [9]: class Base:
   ...:     pass 
   ...: 

In [10]: class Sub(Base):
    ...:     pass 
    ...: 

In [11]: class Sub(Base,object):  # 多继承，在继承列表里存在多个类的时候表示多继承；
    ...:     pass 
    ...: 

In [12]: class Base2:
    ...:     pass 
    ...: 

In [13]: class Sub2(Base,Base2):
    ...:     pass 
    ...: 
```
多继承会把继承列表里的所有公有成员都继承过来；


同名的时候怎么办？



## 多继承


```python
class A():
    pass 
```

```python
class A:
    pass
```

```python
class A(object):
    pass
```

上面三个类在py3中是完全等价的，所有未声明类的都继承自object类；


```python
In [1]: class Base:
   ...:     pass
   ...: 

In [2]: class Sub(Base):
   ...:     pass
   ...: 

In [3]: class Sub(Base,object):
   ...:     pass
   ...: 

In [4]: class Base2:
   ...:     pass
   ...: 

In [5]: class Sub2(Base,Base2):   # 多继承，在继承列表里存在多个类的时候表示多继承； 
   ...:     pass
   ...: 
```


多继承会把继承列表里的所有公有成员都继承过来；

方法或属性同名的时候怎么办？

```python 
In [6]: class A:
   ...:     def method(self):
   ...:         print('method of A')
   ...:         

In [7]: class B:
   ...:     def method(self):
   ...:         print('method of B')
   ...:         

In [8]: class C(A,B):
   ...:     pass
   ...: 

In [9]: c = C()

In [10]: c.method()   # 类C继承时的顺序为A,B,所以类A、B中存在同名方法时，使用A中的；
method of A

In [11]: class D(B,A):
    ...:     pass
    ...: 

In [12]: d = D()

In [13]: d.method()  # 类D继承时的顺序为B、A，所以使用类B中的method方法；
method of B
```

## 顺序查找


```python
In [14]: class E(A):
    ...:     def method(self):
    ...:         print("method of E")
    ...:         

In [15]: class F(A,E):   # 类E继承自A，我个人觉得晚辈应该冲在前面，长辈应该在后面指挥。
    ...:     pass
    ...: 
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-15-6a7ec71d02f4> in <module>()
----> 1 class F(A,E):
      2     pass

TypeError: Cannot create a consistent method resolution
order (MRO) for bases E, A

In [16]: class G(E,A):
    ...:     pass
    ...: 

In [17]: g = G()

In [18]: g.method
Out[18]: <bound method E.method of <__main__.G object at 0x7fc3395965f8>>

In [19]: g.method()
method of E
```

多重继承会引发二义性。
python中一切皆引用，这使得它不会像C++ 一样使用 虚基类 处理基类对象重复的问题，但是如果父类存在同名函数的时候还是会产生二义性。

python中处理这种问题的方法就是MRO。

## MRO: 方法查找顺序

MRO： Method Resolution Order：方法解析顺序；

* 本地优先：自己定义或重写的方法优先；然后按照继承列表，从左到右查找；
* 单调性：所有子类，也要满足查找顺序；


```python
In [2]: class A:
   ...:     def method(self):
   ...:         print("method of A")
   ...:         

In [3]: class B(A):
   ...:     def method(self):
   ...:         print("method of B")
   ...:         

In [4]: class C(A,B):    # 定义不成功，因为B继承自A，B是晚辈，A是长辈；
   ...:     def method(self):
   ...:         print("method of C")
   ...:         
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-4-a8bb2e1a8ce0> in <module>()
----> 1 class C(A,B):
      2     def method(self):
      3         print("method of C")
      4 

TypeError: Cannot create a consistent method resolution
order (MRO) for bases B, A

In [5]: class D(B,A):
   ...:     def method(self):
   ...:         print("method of D")
   ...:         

In [6]: A.__mro__
Out[6]: (__main__.A, object)

In [7]: B.__mro__
Out[7]: (__main__.B, __main__.A, object)

In [8]: D.__mro__
Out[8]: (__main__.D, __main__.B, __main__.A, object)

In [9]: class E(B):
   ...:     pass
   ...: 

In [10]: E.__mro__
Out[10]: (__main__.E, __main__.B, __main__.A, object)
```

(F,A,E,object)   # 不满足E的单调性；

两种MRO的方法
1. 如果是经典类MRO为DFS（深度优先搜索（子节点顺序：从左到右））。
2. 如果是新式类MRO为BFS（广度优先搜索（子节点顺序：从左到右））。

```python
In [1]: class D:
   ...:     def method():
   ...:         print("method of D.")
   ...:         

In [2]: class B(D):
   ...:     pass 
   ...: 

In [3]: class E:
   ...:     pass
   ...: 

In [4]: class C(E):
   ...:     def method():
   ...:         print("method of C")
   ...:         

In [5]: class A(B,C):
   ...:     pass
   ...: 

In [6]: a = A()

In [10]: A.__mro__
Out[10]: (__main__.A, __main__.B, __main__.D, __main__.C, __main__.E, object)
# 查找先从B和B的父类开始查找的顺序，我们称之为单调性。
```

### C3算法

C3算法解决了单调性问题，和只能继承无法重写的问题。

python通过C3算法来确定是否满足mro的两个原则；

```python 
class B(O) -> [B,O]

class B(A1,A2,....,An) -> [B] + merge(mro(A1),mro(A2),...,mro(An),[A1,A2,...An,O])
```

merge： vt.合并；使合并；吞没；vi.合并；融合；

merge的步骤

* 遍历列表；
* 看第一个列表的首元素：
  - 它在其他列表里也是首元素
  - 它在其他列表里不存在；
* 满足以上两种情况，移除，合并到MRO；
* 不满足，抛出异常；


```
mro(G) -> [G] + merge(mro(E),mro(A))
       -> [G] + merge([E,A,O],[A,O],[E,A,O])
       -> [G,E] + merge([A,O],[A,O],[A,O])
       -> [G,E,A] + merge([O],[O],[O])
       -> [G,E,A,O]
```


```
mro(F) -> [F] + merge(mro(A),mro(E),[A,E,O])
       -> [F] + merge([A,O],[E,A,O]，[A,E,O])
       -> raise Exception
```

当一个类定义的时候，解释器会执行C3算法来确定mro，如果C3算法抛出异常，此类不能定义；

应该尽量避免多继承


```python
class A:
    pass

class B(A):
    pass

class C(A):
    pass

class D(B,A):
    pass

class E(C,A):
    pass

class F(E):
    pass 

class G(F,D):
    pass
```

多继承会对程序员的心智负担造成非常大的压力；

python是解释执行的，一段代码只有执行到的时候，才知道有没有错。

多继承是一剂毒药，有的语言(如:java)明确禁止多继承；

类装饰器：

    设置一些类变量；
    
    可以给类增加一些方法；  # 但是不够优雅；

## Mixin

如何以AOP(面向方面)的方式给类增加方法？

       Document

    Word   Excel

printableWord printableExcel

PrintToPrinterWord  



```python
def print_to_printer(cls):
    def print(self):
        pass 
    cls.print_to_printer = print
    return cls 
```

如果一个类，不能动态地增加成员的时候，类装饰器的方法行不通；

### 使用类装饰器方式：

```python
In [44]: class Document:
    ...:     def __init__(self,content):
    ...:         self.content = content
    ...:         

In [45]: class Word(Document):
    ...:     def __init__(self,content):
    ...:         super().__init__('word:{}'.format(content))  # 将'word:content'一起传递给类Document的__init__函数；
    ...:         

In [46]: class Excel(Document):
    ...:     def __init__(self,content):
    ...:         super().__init__('excel:{}'.format(content))
    ...:         

In [47]: def printable(cls):         # 装饰器： 
    ...:     def _print(self):
    ...:         print(self.content)
    ...:     cls.print = _print
    ...:     return cls
    ...: 

In [48]: @printable
    ...: class PrintableWord(Word):
    ...:     def __init__(self,content):     
    ...:         super().__init__(content)      # 将content参数传递给类Word的__init__函数；
    ...:         

In [49]: pw = PrintableWord('abc')

In [50]: pw.print()
word:abc
```

```python
In [52]: def print_to_monitor(cls):
    ...:     def _print(self):
    ...:         print('Monitor:P: {}'.format(self.content))
    ...:     cls.print = _print
    ...:     return cls
    ...: 

In [53]: @print_to_monitor
    ...: class PrintMonitorWord(Word):
    ...:     def __init__(self,content):
    ...:         super().__init__(content)
    ...:         

In [54]: pmw = PrintMonitorWord('abc')

In [55]: pmw.print()
Monitor:P: word:abc
```


---

### 使用mixin方式：

```python
In [56]: class PrintableMixin:
    ...:     def print(self):
    ...:         result = 'P: {}'.format(self.content)
    ...:         print(result)
    ...:         return result
    ...:     

In [57]: class PrintableWord(PrintableMixin,Word):
    ...:     def __init__(self,content):
    ...:         super().__init__(content)
    ...:         

In [58]: pw = PrintableWord('abc')

In [59]: pw.print()
P: word:abc
Out[59]: 'P: word:abc'
```


```python
In [60]: class PrintToMonitorMixin(PrintableMixin):
    ...:     def print(self):
    ...:         print("Monitor:{}".format(super().print()))
    ...:         

In [61]: class PrintToMonitorWord(PrintToMonitorMixin,Word):
    ...:     def __init__(self,content):
    ...:         super().__init__(content)
    ...:         

In [62]: pw = PrintToMonitorWord('abc')

In [63]: pw.print()
P: word:abc
Monitor:P: word:abc
```

Mixin其实也是一种组合的方式；

通常来说，组合优于继承；

Mixin 类的限制：
* Mixin 类不应该有初始化方法；
* Mixin类通常不能独立工作；
* Mixin类的祖先也应该是Mixin类；

通常情况下，Mixin类总在继承列表的第一位；

类： 无法修改

扩展一些方法

扩展的方法，写到一个Mixin类里；

写一个类，继承Mixin和无法修改的类；

新的类就具有了要扩展的方法了。

Mixin是依靠多继承来实现的，除了使用Mixin的时候，尽量避免使用多继承；

---
---

## 魔术方法/专有方法


```python
In [1]: class A:
   ...:     pass
   ...: 

In [2]: dir(A)   # 用内置函数dir()可以得到类A的所有公有成员；
Out[2]: 
['__class__',
 '__delattr__',
 '__dict__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__le__',
 '__lt__',
 '__module__',
 '__ne__',
 '__new__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 '__weakref__']

```

### 属性：
```python 
In [4]: dir(a)   # 调用的是a.__dir__()
Out[4]: 
['__class__',
 '__delattr__',
 '__dict__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__le__',
 '__lt__',
 '__module__',
 '__ne__',
 '__new__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 '__weakref__']

In [5]: a.__dir__()
```


### 类属性：


```python
In [6]: A.__name__    # 类名；
Out[6]: 'A'
```

```python
In [7]: A.__module__  # 模块； 因为是在ipython中，所以都为__main__；
Out[7]: '__main__'
```

```python
In [8]: A.__doc__     # 文档字符串
```


```python
In [9]: A.__class__   # 类型，自定义类的类型都是type；
Out[9]: type
```

### 实例属性：


```python
In [10]: a.__name__
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-10-f972462453b7> in <module>()
----> 1 a.__name__

AttributeError: 'A' object has no attribute '__name__'
```

```python
In [11]: a.__doc__
```


```python
In [12]: a.__module__
Out[12]: '__main__'
```

```python
In [13]: a.__class__
Out[13]: __main__.A

In [14]: lst = list()

In [15]: lst.__class__
Out[15]: list
```




```python
In [16]: a.__class__.__name__   # 得到实例的类名；
Out[16]: 'A'
```

```python
In [17]: a.__dict__   # 实例的所有属性，都保存在__dict__里
Out[17]: {}

In [19]: a.xxx = 3

In [20]: a.__dict__
Out[20]: {'xxx': 3}

In [21]: a.__dict__['xxx'] = 5   # a.__dict__是一个字典，可以通过对其键进行操作；

In [22]: a.xxx
Out[22]: 5

In [23]: a.__dict__
Out[23]: {'xxx': 5}

```

```python
In [24]: a.__dict__[set(1,2,3)] = 5   # set(1,2,3) 对于字典来说是可以做key的，但对于实例不行；
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-24-f025063ed91d> in <module>()
----> 1 a.__dict__[set(1,2,3)] = 5

TypeError: set expected at most 1 arguments, got 3
```



```python
In [25]: a.__dict__
Out[25]: {'xxx': 5}

In [26]: a.__dict__['x y z'] = 10   # 作为字典的键，最好遵守标识符的规则；

In [27]: a
Out[27]: <__main__.A at 0x7f14271b9c50>

In [28]: a.__dict__
Out[28]: {'x y z': 10, 'xxx': 5}

In [29]: a.__dict__['x y z']
Out[29]: 10

In [30]: a.x y z   # 使用点号无法引用包含空格的键；
  File "<ipython-input-30-2a5b2876ab06>", line 1
    a.x y z
        ^
SyntaxError: invalid syntax
```

```python
In [32]: a.__dir__()  # 得到实例的所有成员，包括方法和属性，dir()函数调用的是__dir__()
Out[32]: 
['__dir__',
 '__ge__',
 '__doc__',
 '__subclasshook__',
 '__module__',
 '__repr__',
 '__ne__',
 '__dict__',
 '__format__',
 '__lt__',
 '__reduce_ex__',
 'xxx',
 'x y z',
 '__str__',
 '__sizeof__',
 '__new__',
 '__eq__',
 '__init__',
 '__class__',
 '__weakref__',
 '__delattr__',
 '__reduce__',
 '__getattribute__',
 '__le__',
 '__hash__',
 '__gt__',
 '__setattr__']

 # dir(a)的结果是：   a.__dir__()排序后的结果；
 In [33]: dir(a) == a.__dir__()
Out[33]: False

In [34]: dir(a) == sorted(a.__dir__())
Out[34]: True

In [35]: dir(a) == a.__dir__().sort()
Out[35]: False


In [37]: dir(a) == a.__dir__().sort()
Out[37]: False

In [38]: dir(a).sort() == a.__dir__().sort()
Out[38]: True
```


### 分类：

* 创建/销毁
* 运算符重载
* hash
* bool 
* 可视化
* 反射
* 上下文管理
* 大小
* 描述器
* 杂项

---


### 运算符重载


```python
In [39]: class Point:
    ...:     def __init__(self,x,y):
    ...:         self.x = x
    ...:         self.y = y
    ...:     def add(self,other):
    ...:         return Point(self.x + other.x,self.y + other.y)
    ...:     

In [40]: a = Point(0,0)

In [41]: b = Point(3,5)

In [42]: c = a.add(b)  # 可以通过实例方法进行运算；

In [43]: c.x
Out[43]: 3

In [44]: c.y
Out[44]: 5

In [45]: a + b   # 不支持使用加号运算两个Point实例；
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-45-f96fb8f649b6> in <module>()
----> 1 a + b

TypeError: unsupported operand type(s) for +: 'Point' and 'Point'
```


### 加号(+)重载：

```python
In [46]: class Point:
    ...:     def __init__(self,x,y):
    ...:         self.x = x
    ...:         self.y = y
    ...:     def add(self,other):
    ...:         return Point(self.x + other.x,self.y + other.y)
    ...:     def __add__(self,other):   # 重载加法运算；
    ...:         return Point(self.x + other.x,self.y + other.y)
    ...:     

In [47]: a = Point(0,0)

In [48]: b = Point(3,5)

In [49]: c = a.add(b)

In [51]: print(c.x,c.y)
3 5

In [52]: d = a + b

In [53]: print(d.x,d.y)
3 5
```



```python
In [54]: class Point:
    ...:     def __init__(self,x,y):
    ...:         self.x = x
    ...:         self.y = y
    ...:     def add(self,other):
    ...:         return Point(self.x + other.x,self.y + other.y)
    ...:     def __add__(self,other):  # 调用add方法即可，不用重写一遍；
    ...:         return self.add(other)
    ...:         
    ...:     

In [55]: a = Point(0,0)

In [56]: b = Point(3,5)

In [57]: c = a + b 

In [58]: print(c.x,c.y)
3 5

In [60]: c += Point(4,6)    # 可以使用自增运算符；

In [61]: print(c.x,c.y)
7 11
```



**算数运算**

通过int的帮助信息，可以找到大多数的算数运算符重载方法；

```python 
## 加、减号运算符重载：
In [70]: class Point:
    ...:     def __init__(self,x,y):
    ...:         self.x = x
    ...:         self.y = y
    ...: 
    ...:     def add(self,other):
    ...:         return Point(self.x + other.x,self.y + other.y)
    ...: 
    ...:     def __add__(self,other):
    ...:         return self.add(other)
    ...: 
    ...:     def sub(self,other):
    ...:         return Point(self.x - other.x,self.y - other.y)
    ...: 
    ...:     def __sub__(self, other):
    ...:         return self.sub(other)
    ...:     

In [72]: a = Point(0,0)
    ...: b = Point(3,5)
    ...: c = a + b
    ...: d = a - b
    ...: 

In [73]: print(c.x,c.y)
3 5

In [74]: print(d.x,d.y)
-3 -5

In [75]: c += Point(-3,-4)

In [76]: print(c.x,c.y)
0 1

In [78]: d -= Point(-5,-8)

In [79]: print(d.x,d.y)
2 3

```

### 位运算
### 比较运算
### 成员运算

身份运算和赋值运算，无法重载

不要过度的使用运算符重载


---

# 小结：

## 哲学问题

## 类的定义 
* 类装饰器 


## 类的实例化
* self参数；

## 作用域：
* 类变量：
  - 所有实例共享；
  - 赋值即创建； 


根据首参来决定：
* 类方法 
* 静态方法 
* 实例方法 

## 访问控制 
* 私有成员 
* property


## 继承 
* 基本语法 
* 访问控制 
* 方法重写 
  - super方法
  - super对象 

## 多态： 
* 方法重写 
* 运算符重载  



--- 

* hash
* bool 
* 可视化
* 大小 


```python 
In [3]: hash('abc')
Out[3]: 4256632301310388779

In [4]: hash(123)
Out[4]: 123

In [5]: class Point:
   ...:     pass
   ...: 

In [7]: hash(Point())
Out[7]: 8733801230028

In [10]: object.__hash__
Out[10]: <slot wrapper '__hash__' of 'object' objects>

In [11]: class Point:
    ...:     def __hash__(self):
    ...:         return 1
    ...:         
    ...: 

In [12]: hash(Point())
Out[12]: 1
```

使用内置函数hash()对某个对象求hash值时，会调用对象的`__hash__`方法；

`__hash__`方法必须返回int类型；

```python 
In [13]: class Point:
    ...:     def __hash__(self):
    ...:         return 'abc'
    ...:         
    ...:         
    ...: 

In [15]: hash(Point())
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-15-a919dcea3eae> in <module>()
----> 1 hash(Point())

TypeError: __hash__ method should return an integer

In [21]: class Point:
    ...:     __hash__ = None
    ...:     

In [22]: set([Point()])
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-22-b7932f1140b9> in <module>()
----> 1 set([Point()])

TypeError: unhashable type: 'Point'
```
所谓的可hash对象，就是具有`__hash__`方法的对象；

所有的类都继承自object类，object类具有`__hash__`方法，所以所有类都是可hash的；

要让某个类不可hash，则可以在类中将 `__hash__` 设置为None



```python 
In [25]: class Point:
    ...:     pass
    ...: 

In [26]: p = Point()

In [27]: hash(p)
Out[27]: -9223363303053542256

In [28]: id(p)
Out[28]: 139740819736840

In [30]: p2 = Point()

In [31]: hash(p2)
Out[31]: -9223363303053493055

In [32]: id(p2)
Out[32]: 139740820524056
```

一个类如果没有重写`__hash__`方法的话，这个类的每个实例，通常具有不同的hash。

```python
In [33]: class Point:
    ...:     def __init__(self,x,y):
    ...:         self.x = x
    ...:         self.y = y 
    ...:         

In [34]: p1 = Point(3,5)

In [35]: p2 = Point(3,5)    # 在平面上，p1，p2是两个相同的点；

In [36]: set([p1,p2])    # 但是放到集合中，不能去重；
Out[36]: {<__main__.Point at 0x7f17f1ebcb00>, <__main__.Point at 0x7f17f6131d68>}

In [37]: 

In [37]: class Point:
    ...:     def __init__(self,x,y):
    ...:         self.x = x
    ...:         self.y = y 
    ...:     def __hash__(self):     # 重写__hash__方法，希望能达到去重的效果；
    ...:         return hash('{}:{}'.format(self.x,self.y))
    ...:     

In [38]: p1 = Point(3,5)

In [39]: p2 = Point(3,5)

In [40]: set([p1,p2])
Out[40]: {<__main__.Point at 0x7f17f61aca58>, <__main__.Point at 0x7f17f615ee10>}

In [41]: hash(p1) == hash(p2)    # p1,p2的hash结果已经相等；
Out[41]: True

In [42]: p1 == p2                # 但p1，p2依然不相等，需要实现__eq__方法；
Out[42]: False
```

```python 
In [43]: class Point:
    ...:     def __init__(self,x,y):
    ...:         self.x = x
    ...:         self.y = y 
    ...:     def __hash__(self):
    ...:         return hash('{}:{}'.format(self.x,self.y))
    ...:     def __eq__(self,other):
    ...:         return self.x == other.x and self.y == other.y
    ...:     

In [44]: p1 = Point(3,5)

In [45]: p2 = Point(3,5)

In [46]: set([p1,p2])
Out[46]: {<__main__.Point at 0x7f17f616e8d0>}

In [47]: hash(p1) == hash(p2)
Out[47]: True

In [48]: p1 == p2
Out[48]: True
```
通常`__hash__` 会和`__eq__`一起使用，因为解释器通常同时判断hash是否相等以及实例是否相等；


* 元素的大小：

```python 
In [49]: len([1,2,3])
Out[49]: 3

In [51]: lst = [1,2,3]

In [52]: len(lst)
Out[52]: 3

In [53]: lst.__len__()
Out[53]: 3

In [54]: class Sized:
    ...:     def __len__(self):
    ...:         return 10
    ...:     

In [55]: len(Sized())
Out[55]: 10
```

当对象实现了__len__方法的时候，可以使用内置函数len()求对象的长度；
__len__方法必须返回非负整数；
应用场景： 通常用在自定义数据结构(容器)时；

* __bool__
  - 当对象o实现了`__bool__`方法时，`bool(o)`返回值为`o.__bool__()`
  - ~~当对象o没有实现`__bool__`方法时，bool(o)永远返回True；~~
  - 当对象o没有实现`__bool__`方法的时候，如果o实现了`__len__`方法，`bool(o)`返回值为`len(o) != 0`
  - 当对象o既没有实现`__bool__`方法，也没有实现`__len__`方法的时候，`bool(o)`返回True。
  - __bool__优先级更高；
  - __bool__方法必须返回bool类型；

应用场景： 用在if 或 while判断时；

```python
In [56]: if None:
    ...:     pass
    ...: 

In [57]: bool(None)
Out[57]: False

In [58]: bool(0)
Out[58]: False

In [59]: class Boolean:
    ...:     pass
    ...: 

In [60]: bool(Boolean())
Out[60]: True

In [61]: class F:
    ...:     def __bool__(self):
    ...:         return False
    ...:     

In [62]: bool(F())
Out[62]: False

In [63]: class T:
    ...:     def __bool__(self):
    ...:         return True
    ...:     

In [64]: bool(T())
Out[64]: True
```

```python
In [65]: class Sized:
    ...:     def __init__(self,size):
    ...:         self.size = size
    ...:     def __len__(self):
    ...:         return self.size
    ...:     

In [66]: bool(Sized(0))
Out[66]: False

In [67]: bool(Sized(10))
Out[67]: True
```

```python 
In [68]: class Sized:
    ...:     def __init__(self,size):
    ...:         self.size = size
    ...:     def __len__(self):
    ...:         return self.size
    ...:     def __bool__(self):
    ...:         return self.size == 0
    ...:     

In [69]: bool(Sized(0))
Out[69]: True

In [70]: bool(Sized(10))
Out[70]: False
```

```python
In [71]: class B:
    ...:     def __bool__(self):
    ...:         return None
    ...:     

In [72]: bool(B())
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-72-4efbb03885fe> in <module>()
----> 1 bool(B())

TypeError: __bool__ should return bool, returned NoneType
```

* 对象可视化： 
  - `__str__()`   # 给人读的；
  - `__repr__()`  # 给机器读的；


```python
In [73]: class A:
    ...:     pass
    ...: 

In [74]: print(A())
<__main__.A object at 0x7f17f615ec18>

In [75]: class Point:
    ...:     def __init__(self,x,y):
    ...:         self.x = x
    ...:         self.y = y
    ...:         

In [76]: print(Point(3,5))
<__main__.Point object at 0x7f17f615e5c0>


In [79]: class Point:
    ...:     def __init__(self,x,y):
    ...:         self.x = x
    ...:         self.y = y
    ...:     def __str__(self):
    ...:         return 'Point<{},{}>'.format(self.x,self.y)
    ...:     

In [80]: print(Point(3,5))
Point<3,5>
```

```python 
In [81]: class Point:
    ...:     def __init__(self,x,y):
    ...:         self.x = x
    ...:         self.y = y
    ...:     def __str__(self):
    ...:         return 'Point<{},{}>'.format(self.x,self.y)
    ...:     def __repr__(self):
    ...:         return 'Point({},{})'.format(self.x,self.y)
    ...:     

In [82]: repr(Point(3,5))
Out[82]: 'Point(3,5)'
```


* ## callable对象：

```python 
In [84]: def fn():
    ...:     pass
    ...: 

In [85]: fn()

In [86]: fn.__class__
Out[86]: function

In [87]
```

可以通过小括号的方式调用的对象，就是callable对象；

所有的函数都是类function的实例；

```python 
In [87]: class Fn:
    ...:     def __call__(self):   
    ...:         print('{} called'.format(self))
    ...:         

In [88]: f = Fn()

In [89]: f()
<__main__.Fn object at 0x7f17f61540f0> called
```
### 一个对象只要实现了__call__方法就可以通过小括号来调用，这一类对象称之为可调用对象；


内置函数callable可以测试对象是否是可调用对象；
```python 
In [90]: callable(f)
Out[90]: True

In [91]: callable(fn)
Out[91]: True

In [92]: callable(lambda x: x)
Out[92]: True
```


```python
In [93]: class Adder:
    ...:     def __call__(self,x,y):
    ...:         return x + y
    ...:     

In [94]: Adder()(3,5)
Out[94]: 8
```

```python
In [95]: class A:
    ...:     pass
    ...: 

In [96]: A()()   # 类A中未定义__call__方法，所以实例出来的对象不可调用；
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-96-7a9d38a85bf0> in <module>()
----> 1 A()()

TypeError: 'A' object is not callable
```


复杂的装饰器使用类来写，可以方便地拆分逻辑；

用`__call__`来实现可调用对象，和闭包是殊途同归的，通常是为了封装一些内部状态；


--- 

* ## 上下文管理 

```python 
In [97]: with open('./haha.txt') as f:
    ...:     pass
    ...: 
```

open函数，返回的是一个文件对象，而文件对象是支持上下文管理的；

**支持上下文管理的对象**，可以使用以下语法：

```python 
with obj:
    pass 
```

```python
In [98]: class Context:
    ...:     def __enter__(self):
    ...:         print('enter context')
    ...:     def __exit__(self,*args,**kwargs):
    ...:         print('exit context')
    ...:         
```

当一个对象同时实现了`__enter__` 和 `__exit__`方法，那么这个对象就是支持上下文管理的对象；


```python 
In [98]: class Context:
    ...:     def __enter__(self):
    ...:         print('enter context')
    ...:     def __exit__(self,*args,**kwargs):
    ...:         print('exit context')
    ...:         

In [99]: with Context():
    ...:     print('Do something')
    ...:     
enter context
Do something
exit context

In [100]: with Context():
     ...:     print('Do something')
     ...: print("out of context")
     ...: 
enter context
Do something
exit context
out of context
```

进入`with`语句块之前，会执行`__enter__`方法，退出`with`语句块之前，会执行`__exit__`方法；

为什么叫上下文？

`with`开启一个语句块，执行这个语句块之前，会执行`__enter__`方法，执行这个语句块之后，会执行`__exit__`方法；

也就是说在这个语句块的前后会执行一些操作，所以叫做上下文管理；



上下文管理是否安全？

```python 
In [101]: with Context():
     ...:     raise Exception()
     ...: 
enter context
exit context
# 即使`with`块跑出异常，`__enter__`和`__exit__`还是会执行，所以上下文管理是安全的；
---------------------------------------------------------------------------
Exception                                 Traceback (most recent call last)
<ipython-input-101-c1afee4bfdab> in <module>()
      1 with Context():
----> 2     raise Exception()

Exception: 
```
### 即使`with`块跑出异常，`__enter__`和`__exit__`还是会执行，所以上下文管理是安全的；



介绍一个极端的异常：SystemExit,可能会直接导致解释器结束；

```python
In [102]: import sys

In [103]: with Context():
     ...:     sys.exit()
     ...:     
enter context
exit context
An exception has occurred, use %tb to see the full traceback.

SystemExit

/home/kalaguiyin/.pyenv/versions/3.5.2/envs/sslinux/lib/python3.5/site-packages/IPython/core/interactiveshell.py:2889: UserWarning: To exit: use 'exit', 'quit', or Ctrl-D.
  warn("To exit: use 'exit', 'quit', or Ctrl-D.", stacklevel=1)
```


```python 
import sys

class Context:
    def __enter__(self):
        print("__enter__")

    def __exit__(self, *args,**kwargs):
        print('__exit__')

with Context():
    sys.exit()

print("exited")    # 不会执行；因为sys.exit()退出了解释器；

# 运行结果：
__enter__
__exit__
```

即使`with`块中主动退出解释器，`__enter__`和`__exit__`也能保证执行；


```python 
In [104]: ctx = Context()

In [105]: with ctx as c:
     ...:     print(id(ctx))
     ...:     print(id(c))
     ...:     
enter context
139740820524896
8851424
exit context

In [106]: with ctx as c:
     ...:     print(id(ctx))    # 此时ctx和c的id居然不一致！
     ...:     print(id(c))
     ...:     print(c)
     ...:     
enter context
139740820524896
8851424
None
exit context
```

```python 
# 修改了Context类中的__enter__方法的返回值；
In [107]: class Context:
     ...:     def __enter__(self):
     ...:         print('enter context')
     ...:         return self
     ...:     def __exit__(self,*args,**kwargs):
     ...:         print('exit context')
     ...:         

In [108]: ctx = Context()

In [109]: with ctx as c:
     ...:     print(id(ctx))
     ...:     print(id(c))
     ...:     print(c)
     ...:     
enter context    # 再一看，ctx和c的id值一样了哦！
139740889734448
139740889734448
<__main__.Context object at 0x7f17f617dd30>
exit context
```

`as`子句可以获取`__enter__`方法的返回值； 

```python 
In [110]: class Context:
     ...:     def __enter__(self):
     ...:         print('enter context')
     ...:         return "神秘北极熊"
     ...:     def __exit__(self,*args,**kwargs):
     ...:         print('exit context')
     ...:         

In [111]: with Context() as s:
     ...:     print(s)
     ...:     
enter context
神秘北极熊
exit context
```
---

`__enter__`除self之外，不带任何参数。
```python
In [112]: class Context:
     ...:     def __enter__(self,*args,**kwargs):
     ...:         print('enter context')
     ...:         print(args)
     ...:         print(kwargs)
     ...:     def __exit__(self,*args,**kwargs):
     ...:         print('exit context')
     ...:         

In [113]: with Context():
     ...:     pass
     ...: 
enter context
()
{}
exit context
```

---

`__exit__`的返回值，没有办法获取到;

如果`with`语句块里面抛出异常，`__exit__`返回False的时候，会向上抛出异常，返回True的时候，会屏蔽异常。

```python 
In [114]: class Context:
     ...:     def __enter__(self):
     ...:         print('enter context')
     ...:         
     ...:     def __exit__(self,*args,**kwargs):
     ...:         print('exit context')
     ...:         return 'haha'
     ...:         

In [115]: with Context():
     ...:     pass
     ...: 
enter context
exit context

In [116]: with Context() as c:
     ...:     print(c)
     ...:     pass
     ...: 
enter context
None
exit context
```


`__exit__`的参数的意义：

```python 
In [117]: class Context:
     ...:     def __enter__(self):
     ...:         print('enter context')
     ...:         
     ...:     def __exit__(self,*args,**kwargs):
     ...:         print('exit context')
     ...:         print(args)
     ...:         print(kwargs)
     ...:         
     ...:         

In [118]: with Context():
     ...:     pass
     ...: 
enter context
exit context
(None, None, None)
{}

# 三个位置参数，跟异常相关；
In [119]: with Context():
     ...:     raise Exception()
     ...: 
enter context
exit context
(<class 'Exception'>, Exception(), <traceback object at 0x7f17f61a4c08>)
{}
---------------------------------------------------------------------------
Exception                                 Traceback (most recent call last)
<ipython-input-119-c1afee4bfdab> in <module>()
      1 with Context():
----> 2     raise Exception()

Exception:
```

```python 
# __exit__函数的原型，参数用来处理异常；
In [120]: class Context:
     ...:     def __enter__(self):
     ...:         print('enter context')
     ...:         
     ...:     def __exit__(self,exc_type,exc,traceback):
     ...:         print('exit context')
     ...:         print('exception:{}'.format(exc_type))
     ...:         
     ...:         
     ...:         

In [121]: with Context():
     ...:     raise TypeError('haha')
     ...: 
enter context
exit context
exception:<class 'TypeError'>
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-121-8f8e41227d75> in <module>()
      1 with Context():
----> 2     raise TypeError('haha')

TypeError: haha
```

`__exit__`的三个参数：异常类型，异常，traceback 


---

### 用装饰器实现计时功能：

```python 
In [125]: import datatime 
In [126]: from functools import wraps

In [127]: def timeit(fn):
     ...:     @wraps(fn)
     ...:     def wrap(*args,**kwargs):
     ...:         start = datetime.datetime.now()
     ...:         ret = fn(*args,**kwargs)
     ...:         cost = datetime.datetime.now() - start
     ...:         print(cost)
     ...:         return ret
     ...:     return wrap
     ...: 

In [128]: @timeit
     ...: def add(x,y):
     ...:     return x + y
     ...: 

In [129]: add(3,8)
0:00:00.000034
Out[129]: 11
```

### 用上下文管理实现计时功能：

```python 
# 对一段代码的执行进行计时：
In [132]: class Timeit:
     ...:     def __enter__(self):
     ...:         self.start = datetime.datetime.now()
     ...:     def __exit__(self,*args):
     ...:         cost = datetime.datetime.now() - self.start
     ...:         print(cost)
     ...:         

In [133]: with Timeit():
     ...:     z = 3 + 8 
     ...:     
0:00:00.000041
```


```python 
In [141]: class Timeit:
     ...:     def __init__(self,fn=None):
     ...:         wraps(fn)(self)
     ...:     def __call__(self,*args,**kwargs):
     ...:         start = datetime.datetime.now()
     ...:         ret = self.__wrapped__(*args,**kwargs)
     ...:         cost = datetime.datetime.now() - start
     ...:         print(cost)
     ...:         return ret
     ...:     def __enter__(self):
     ...:         self.start = datetime.datetime.now()
     ...:     def __exit__(self,*args):
     ...:         cost = datetime.datetime.now() - self.start
     ...:         print(cost)
     ...:         

In [142]: with Timeit():
     ...:     z = 3 + 8
     ...:     
0:00:00.000027

In [143]: @Timeit
     ...: def add(x,y):
     ...:     return x + y
     ...: 

In [144]: add(3,8)
0:00:00.000032
Out[144]: 11
```

## 上下文管理的使用场景：

**凡是要在代码块前后插入代码的场景通通适用；**
- 资源管理：打开的文件，网络，数据库连接等；
- 权限验证：


```python 
In [145]: import contextlib

In [146]: @contextlib.contextmanager
     ...: def context():
     ...:     print('enter context') # 初始化部分，相当于__enter__方法。
     ...:     try:
     ...:         yield 'haha'       # 相当于__enter__的返回值；
     ...:     finally:
     ...:         print('exit context') # 清理部分，相当于__exit__方法
     ...:         
     ...:         

In [147]: with context() as c:
     ...:     print(c)
     ...:     
enter context
haha
exit context

In [148]: with context() as c:
     ...:     print(c)
     ...:     raise Exception()
     ...: 
enter context
haha
exit context
---------------------------------------------------------------------------
Exception                                 Traceback (most recent call last)
<ipython-input-148-4c1dae6b647a> in <module>()
      1 with context() as c:
      2     print(c)
----> 3     raise Exception()

Exception: 
```

装饰器: @contextlib.contextmanager可以将一个函数转换为能被`with`上下文管理的函数；

---

* ## 作业：实现 contextlib.contextmanager装饰器；



---

* ## 反射：  

运行时获取类的信息；

```python 
In [150]: class Point:
     ...:     def __init__(self,x,y):
     ...:         self.x = x
     ...:         self.y = y 
     ...:     def print(self,x,y):
     ...:         print(x,y)
     ...:             

In [151]: p = Point(3,5)

In [152]: p.__dict__
Out[152]: {'x': 3, 'y': 5}

In [153]: p.__dict__['z'] = 10

In [154]: p.z
Out[154]: 10

In [155]: dir(p)    # 获取对象p的所有属性和方法；
Out[155]: 
['__class__',
 '__delattr__',
 '__dict__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__le__',
 '__lt__',
 '__module__',
 '__ne__',
 '__new__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 '__weakref__',
 'print',
 'x',
 'y',
 'z']
```

## 三个内置函数：getattr,setattr,hasattr 

* 通过成员名称，获取对象的成员；

```python 
In [156]: p.__dict__['x']   # 对于属性来说，可以通过__dict__获取
Out[156]: 3

In [157]: getattr(p,'print')
Out[157]: <bound method Point.print of <__main__.Point object at 0x7f17f1e0f7f0>>

# 相当于p.print(3,5)
In [158]: getattr(p,'print')(3,5)  ## 成员方法无法通过__dict__获取，但是可以通过getattr函数获取；
3 5

In [159]: getattr(p,'x')    # getattr函数也可以获取到属性；
Out[159]: 3

```

- setattr 设置对象的成员的值；

只能创建属性，不能创建方法；

因为： setattr 对象是实例，实例是无法动态增加方法的；

```python
In [160]: setattr(p,'haha','abcd')

In [161]: p.haha
Out[161]: 'abcd'
```


- hasattr 判断对象是否具有某成员；
```python 
In [162]: hasattr(p,'print')
Out[162]: True

In [163]: hasattr(p,'not_found')
Out[163]: False
```








